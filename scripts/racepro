#!/usr/bin/python

import os
import sys
import pdb
import argparse
import logging
import networkx
from itertools import *

from racepro import *

##############################################################################
def show_syscalls(args):
    session = Session(load_events(args.logfile))
    for proc in session.processes.itervalues():
        for sys in proc.syscalls:
            print('[%d][%3d] %s' %
                  (proc.pid, sys.syscall_index + 1, sys))
        print('')
    return 0

##############################################################################
def show_races(args):
    graph = ExecutionGraph(load_events(args.logfile))
    logging.debug('graph: %s' % networkx.convert.to_edgelist(graph))

    def output_races(race_list, desc, count, limit):
        print('-' * 79)
        print('%s' % desc)
        print('  found %d potential races' % len(race_list))
        logging.debug('Race list %s' % race_list)
        print('-' * 79)
        for race in race_list:
            if count >= limit:
                break;
            if race.prepare(graph):
                print('RACE %2d: %s' % (count + 1, race))
                race.output(graph, args.outfile + '.' + str(count + 1))
                count += 1
        return count

    total = 0
    count = 0

    # step 1: find resource races
    race_list = RaceList(graph, RaceResource.find_races)
    race_list = sorted(race_list, reverse=True, key=lambda race: race.rank)
    total += len(race_list)
    count = output_races(race_list, 'RESOURCE RACES', count, args.count)

    # step 2: find exit-exit-wait races
    if args.no_exit_races:
        race_list = list()
    else:
        race_list = RaceList(graph, RaceExitWait.find_races)
    total += len(race_list)
    count = output_races(race_list, 'EXIT-WAIT RACES', count, args.count)

    # step 3: find signal races
    if args.no_signal_races:
        race_list = list()
    else:
        race_list = RaceList(graph, RaceSignal.find_races)
    total += len(race_list)
    count = output_races(race_list, 'SIGNAL RACES', count, args.count)

    # step 4: statistics
    print('Generated %d logs for races out of %d candidates' % (count, total))
    print('-' * 79)

    return count

##############################################################################
def show_toctou(args):
    graph = ExecutionGraph(load_events(args.logfile))
    logging.debug('graph: %s' % networkx.convert.to_edgelist(graph))

    total = 0
    count = 1

    # step 1: find toctou races
    race_list = RaceList(graph, RaceToctou.find_races)
    total += len(race_list)
    count = output_races(race_list, 'TOCTOU RACES', count, args.count)

    # step 2: statistics
    print('Generated %d logs for races of of %d candidates' % (count, total))
    print('-' * 79)

    return count

##########################################################################

parser_io = argparse.ArgumentParser(add_help=False)
parser_io.add_argument('logfile', metavar='INPUT',
                       help='File name of input log')
parser_io.add_argument('-o', '--output', dest='outfile', metavar='PREFIX',
                       help='Prefix for output files')

parser_races = argparse.ArgumentParser(add_help=False)
parser_races.add_argument('-c', '--count', dest='count',
                          metavar='COUNT', type=int, default=1000,
                          help='Limit results to COUNT races')
parser_races.add_argument('--no-depend', dest='nodepend',
                          action='store_true', default=False,
                          help='Disregard happened-before dependencies')
parser_races.add_argument('--no-exit-races', dest='no_exit_races',
                          action='store_true', default=False,
                          help='Do not detect exit-exit-wait race')
parser_races.add_argument('--no-signal-races', dest='no_signal_races',
                          action='store_true', default=False,
                          help='Do not detect signal race')

desc = 'Process and modify scribe execution log'
parser = argparse.ArgumentParser(description=desc)
parser.add_argument('-d', dest='debug',
                    action='store_true', default=False,
                    help='Increase debug vebosity')
parser.add_argument('-v', dest='verbose',
                    action='store_true', default=False,
                    help='Increase vebosity level')

subparsers = parser.add_subparsers(title='subcommands')

parser_show_syscalls = subparsers.add_parser(
    'show-syscalls', parents=[parser_io])
parser_show_syscalls.set_defaults(func=show_syscalls)

parser_show_races = subparsers.add_parser(
    'show-races', parents=[parser_io, parser_races])
parser_show_races.set_defaults(func=show_races)

parser_show_toctou = subparsers.add_parser(
    'show-toctou', parents=[parser_io])
parser_show_toctou.set_defaults(func=show_toctou)

args = parser.parse_args()

log = logging.ERROR
if args.verbose: log = logging.INFO
if args.debug: log = logging.DEBUG
logging.basicConfig(level=log, stream=sys.stdout)

if not args.outfile:
    args.outfile = os.path.splitext(args.logfile)[0]

ret = args.func(args)
exit(0 if ret >= 0 else -ret)
