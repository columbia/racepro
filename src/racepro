#!/usr/bin/python

import os
import sys
import random
import argparse
import logging
import networkx
import pygraphviz
from itertools import *

import scribe
import racepro
import unistd

def load_session(logfile):
    try:
        file = open(logfile, 'r')
    except:
        print('Cannot open log file')
        exit(1)

    session = racepro.Session()
    session.load_events(file)
    return session

##############################################################################

def diet_graph(graph):
    for n in graph.nodes():
        if graph.in_degree(n) != 1 or graph.out_degree(n) != 1:
            continue
        t = graph.successors(n)[0]
        s = graph.predecessors(n)[0]
        if s.split(':')[0] != n.split(':')[0]:
            continue
        if n.split(':')[0] != t.split(':')[0]:
            continue
        graph.remove_edge(s, n)
        graph.remove_edge(n, t)
        graph.remove_node(n)
        graph.add_edge(s, t)

def show_graph(args):

    def style_cluster(graph, output):
        with open(output, 'w') as file:
            file.write('digraph G {\n')
            for pid in session.process_map.keys():
                file.write('\tsubgraph cluster_%d {\n' % pid)
                nodes = [ n for n in graph.nodes() if n.split(':')[0] == str(pid) ]
                nodes.sort(key=lambda n : int(n.split(':')[1]))
                file.write('\t\t"' + '" -> "'.join(nodes) + '";\n')
                file.write('\t}\n')
            for s, t in graph.edges():
                if s.split(':')[0] != t.split(':')[0]:
                    file.write('\t"%s" -> "%s";\n' % (s, t))
            file.write('}\n')

    def style_plain(graph, output):
        networkx.write_dot(graph, output)

    def do_show_graph(graph, output):
        plot = style_cluster if args.clustered else style_plain
        plot(graph, output + '.dot')
        g = pygraphviz.AGraph(output + '.dot')
        g.layout(prog='dot')
        g.draw(output + '.pdf')

    session = load_session(args.logfile)
    graph = session.make_graph(full=False, resources=False)
    if args.thin:  diet_graph(graph)
    do_show_graph(graph, args.outfile + '.hb')

    session = load_session(args.logfile)
    graph = session.make_graph(full=True, resources=True)
    if args.thin:  diet_graph(graph)
    do_show_graph(graph, args.outfile + '.ob')

    return(0)

##############################################################################

def show_races(args):
    session = load_session(args.logfile)

    graph = session.make_graph(full=True, resources=True)
    logging.debug('graph: %s' % networkx.convert.to_edgelist(graph))

    vclocks = session.vclock_graph(graph)
    for k in vclocks.keys():
        logging.debug('%2d %5d -> %s' % (k[0].pid, k[1], vclocks[k].clocks))

    all_races = session.races_resources(vclocks)
    logging.debug('total races %d' % (len(all_races)))

    sys_races = set()
    map_races = dict()

    for vc1, i1, vc2, i2 in all_races:
        s_ev1 = session.events_list[i1]
        r_ev1 = s_ev1.resource.events[s_ev1.rindex]
        proc1, pindex1 = session.r_ev_to_proc(r_ev1, sysind=True)
        p_ev1 = proc1.events[pindex1]
        node1 = session.make_node(proc1.pid, p_ev1.syscnt)

        s_ev2 = session.events_list[i2]
        r_ev2 = s_ev2.resource.events[s_ev2.rindex]
        proc2, pindex2 = session.r_ev_to_proc(r_ev2, sysind=True)
        p_ev2 = proc2.events[pindex2]
        node2 = session.make_node(proc2.pid, p_ev2.syscnt)

        logging.debug('[vc %s pid %d cnt %d  <->  vc %s pid %d cnt %d]' %
                      (vc1.clocks, proc1.pid, p_ev1.syscnt,
                       vc2.clocks, proc2.pid, p_ev2.syscnt))

        if r_ev1.event.serial < r_ev2.event.serial:
            node1, node2 = node2, node1
            i1, i2 = i2, i1

        sys_races.add((node1, node2))

        try:
            map_races[(node1, node2)].append((i1, i2))
        except KeyError:
            map_races[(node1, node2)] = list([(i1, i2)])

    print('Found %d potential races (%d after duplicates removal)' %
          (len(all_races), len(sys_races)))

    if len(all_races) == 0:
        return 0

    r = random.sample(sys_races, len(sys_races))

    print('Random sample to generate at most %d races:' % (args.count))
    print('-' * 75)

    n_race = 0
    n_fail = 0

    for (node1, node2) in r:
        proc1, pindex1 = session.split_node(node1)
        event1 = session.events_list[int(graph.node[node1]['index'])].event

        proc2, pindex2 = session.split_node(node2)
        event2 = session.events_list[int(graph.node[node2]['index'])].event

        bookmark1 = session.crosscut_graph(graph, vclocks, node1, node2)
        if not bookmark1:
            print('No consistent cut: pid %d syscnt %d --> pid %d syscnt %d' %
                  (proc1.pid, pindex1, proc2.pid, pindex2))
            n_fail += 1
            continue

        print('RACE %2d:  ' % (n_race + 1) +
              'pid %d syscnt %d [sys(%d)=%d]' %
              (proc1.pid, pindex1, event1.nr, event1.ret) +
              '  -->   pid %d syscnt %d [sys(%d)=%d]' %
              (proc2.pid, pindex2, event2.nr, event2.ret))
        print('          cut:  %s' % bookmark1.values())

        bookmark2 = dict(bookmark1)
        bookmark2[proc1.pid] = -bookmark2[proc1.pid]
        bookmarks = [bookmark1, bookmark2]

        action = racepro.Action(scribe.SCRIBE_INJECT_ACTION_PSFLAGS,
                                0, scribe.SCRIBE_PS_ENABLE_RESOURCE)
        injects = dict()
        injects[proc1.pid] = dict({-pindex1 : action})

        cutoff = dict(bookmark2)

        logging.debug('   boobkmark1: %s' % (bookmark1))
        logging.debug('   boobkmark2: %s' % (bookmark2))
        logging.debug('   injects: %s' % (injects))
        logging.debug('   cutoff: %s' % (cutoff))

        outfile = open(args.outfile + '.' + str(n_race + 1) + '.log', 'w')
        session.save_events(outfile,
                            bookmarks=bookmarks,
                            injects=injects,
                            cutoff=cutoff)
        outfile.close()

        n_race += 1
        if (n_race == args.count):
            break;

    print('-' * 75)
    print('Generated %d logs out of total %d races examined' %
          (n_race, n_race + n_fail))
    print('-' * 75)

    return n_race

##############################################################################

def test_races(args):
    cmd_replay = 'sudo replay -c 1'
    cmd_suffix = ' > /dev/null 2>&1' if args.silent else ''

    if args.detect:
        total = show_races(args)
    else:
        total = -1

    n = 0
    while True:
        n += 1
        if total >= 0 and n > total:
            break;
        logfile = '%s.%d.log' % (args.outfile, n)
        if not os.access(logfile, os.R_OK):
            break

        if args.script_pre:
            ret = os.system('sudo ' + args.script_pre + cmd_suffix)
            if ret > 0:
                print('Bad exit code %d from pre-script'
                      ' (race %d)... skipping' % (ret, n))
                continue;

        logging.debug('command: %s %s %s' % (cmd_replay, logfile, cmd_suffix))
        ret = os.system('%s %s %s' % (cmd_replay, logfile, cmd_suffix))
        if ret > 0:
            print('REPLAY %2d: failed (exit %d)' % (n, ret))
            continue
        else:
            print('REPLAY %2d: completed' % n)
            success = True

        if args.script_test:
            ret = os.system('sudo ' + args.script_test + cmd_suffix)
            if ret == 2:
                print('Bad exit code %d from test-script'
                      ' (race %d)... skipping' % (ret, n))
                continue
            success = True if ret == 1 else False

        print('    BUG %s' % ('PRODUCED' if success else 'not triggered'))

        if args.script_post:
            ret = os.system('sudo ' + args.script_post + cmd_suffix)
            if ret > 0:
                print('Bad exit code %d from post-script'
                     ' (race %d)' % (ret, n))

##############################################################################

parser_io = argparse.ArgumentParser(add_help=False)
parser_io.add_argument('-i', '--input', dest='logfile',
                       metavar='FILE', required=True)
parser_io.add_argument('-o', '--output', dest='outfile',
                       metavar='FILE', required=True)

parser_races = argparse.ArgumentParser(add_help=False)
parser_races.add_argument('-c', '--count', dest='count',
                          metavar='COUNT', type=int, default=1000,
                          help='Limit results to COUNT races')
parser_races.add_argument('-r', '--random', dest='random',
                          action='store_true', default=False,
                          help='List races in random order')

desc = 'Process and modify scribe execution log'
parser = argparse.ArgumentParser(description=desc)
parser.add_argument('-d', dest='debug',
                    action='store_true', default=False,
                    help='Increase debug vebosity')
parser.add_argument('-v', dest='verbose',
                    action='store_true', default=False,
                    help='Increase vebosity level')

subparsers = parser.add_subparsers(title='subcommands')

parser_show_graph = subparsers.add_parser(
    'show-graph', parents=[parser_io])
parser_show_graph.set_defaults(func=show_graph)
parser_show_graph.add_argument('-c', '--clustered', dest='clustered',
                               action='store_true',
                               help='Clustered output style')
parser_show_graph.add_argument('-t', '--thin', dest='thin',
                               action='store_true',
                               help='Thin mode (minimal syscalls graph')

parser_show_races = subparsers.add_parser(
    'show-races', parents=[parser_io, parser_races])
parser_show_races.set_defaults(func=show_races)

parser_test_races = subparsers.add_parser(
    'test-races', parents=[parser_io, parser_races])
parser_test_races.set_defaults(func=test_races)
parser_test_races.add_argument('--script-pre', dest='script_pre',
                               default=None,
                               help='Script to run before test')
parser_test_races.add_argument('--script-post', dest='script_post',
                               default=None,
                               help='Script to run after test')
parser_test_races.add_argument('--script-test', dest='script_test',
                               default=None,
                               help='Script to check success of test')
parser_test_races.add_argument('-s', '--silent', dest='silent',
                               action='store_true', default=False,
                               help='Hide scribe/scripts/tests output')
parser_test_races.add_argument('-d', '--detect', dest='detect',
                               action='store_true', default=False,
                               help='Detect races and generate logs')

args = parser.parse_args()

log = logging.ERROR
if args.verbose: log = logging.INFO
if args.debug: log = logging.DEBUG
logging.basicConfig(level=log, stream=sys.stdout)

ret = args.func(args)

exit(ret)
