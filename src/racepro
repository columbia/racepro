#!/usr/bin/python

import os
import sys
import random
import argparse
import logging
import networkx

import scribe
import racepro
import unistd

def load_session(logfile):
    try:
        file = open(logfile, 'r')
    except:
        logging.error('Failed to open log file')
        exit(1)

    session = racepro.Session()
    session.load_events(file)
    return session

##############################################################################

def show_graph(args):
    session = load_session(args.logfile)
    graph = session.make_graph(full=False, resources=False)
    networkx.write_dot(graph, args.outfile + '.hb.dot')
    session = load_session(args.logfile)
    graph = session.make_graph(full=True, resources=True)
    networkx.write_dot(graph, args.outfile + '.ob.dot')
    return(0)

##############################################################################

def show_races(args):
    session = load_session(args.logfile)

    graph = session.make_graph(full=True, resources=True)
    logging.debug('graph: %s' % networkx.convert.to_edgelist(graph))

    vclocks = session.vclock_graph(graph)
    for k in vclocks.keys():
        logging.debug('%2d %5d -> %s' % (k[0].pid, k[1], vclocks[k].clocks))

    all_races = session.races_resources(vclocks)
    logging.debug('total races %d' % (len(all_races)))

    sys_races = set()
    map_races = dict()

    for vc1, i1, vc2, i2 in all_races:
        s_ev1 = session.events_list[i1]
        r_ev1 = s_ev1.resource.events[s_ev1.rindex]
        proc1, pindex1 = session.r_ev_to_proc(r_ev1, sysind=True)
        p_ev1 = proc1.events[pindex1]
        node1 = session.make_node(proc1.pid, p_ev1.syscnt)

        s_ev2 = session.events_list[i2]
        r_ev2 = s_ev2.resource.events[s_ev2.rindex]
        proc2, pindex2 = session.r_ev_to_proc(r_ev2, sysind=True)
        p_ev2 = proc2.events[pindex2]
        node2 = session.make_node(proc2.pid, p_ev2.syscnt)

        logging.debug('[vc %s pid %d cnt %d  <->  vc %s pid %d cnt %d]' %
                      (vc1.clocks, proc1.pid, p_ev1.syscnt,
                       vc2.clocks, proc2.pid, p_ev2.syscnt))

        if r_ev1.event.serial < r_ev2.event.serial:
            node1, node2 = node2, node1
            i1, i2 = i2, i1

        sys_races.add((node1, node2))

        try:
            map_races[(node1, node2)].append((i1, i2))
        except KeyError:
            map_races[(node1, node2)] = list([(i1, i2)])

    logging.info('Found %d potential races (%d after duplicates removal)' %
                 (len(all_races), len(sys_races)))

    if len(all_races) == 0:
        return 0

    r = random.sample(sys_races, len(sys_races))

    logging.info('Random sample to generate at most %d races:' %(args.number))
    logging.info('-' * 75)

    n_race = 0
    n_fail = 0

    for (node1, node2) in r:
        proc1, pindex1 = session.split_node(node1)
        event1 = session.events_list[int(graph.node[node1]['index'])].event

        proc2, pindex2 = session.split_node(node2)
        event2 = session.events_list[int(graph.node[node2]['index'])].event

        bookmark1 = session.crosscut_graph(graph, vclocks, node1, node2)
        if not bookmark1:
            logging.info('No consistent cut for: ' +
                         'pid %d syscnt %d  -->  pid %d syscnt %d'
                         % (proc1.pid, pindex1, proc2.pid, pindex2))
            n_fail += 1
            continue

        logging.info('RACE %2d:  ' % (n_race + 1) +
                     'pid %d syscnt %d [sys(%d)=%d]' %
                     (proc1.pid, pindex1, event1.nr, event1.ret) +
                     '  -->   pid %d syscnt %d [sys(%d)=%d]' %
                     (proc2.pid, pindex2, event2.nr, event2.ret))
        logging.info('          cut:  %s' % bookmark1.values())

        bookmark2 = dict(bookmark1)
        bookmark2[proc1.pid] = -bookmark2[proc1.pid]
        bookmarks = [bookmark1, bookmark2]

        action = Action(scribe.SCRIBE_INJECT_ACTION_PSFLAGS,
                        0, scribe.SCRIBE_PS_ENABLE_RESOURCE)
        injects = dict()
        injects[proc1.pid] = dict({-pindex1 : action})

        cutoff = dict(bookmark2)

        logging.debug('   boobkmark1: %s' % (bookmark1))
        logging.debug('   boobkmark2: %s' % (bookmark2))
        logging.debug('   injects: %s' % (injects))
        logging.debug('   cutoff: %s' % (cutoff))

        outfile = open(args.outfile + '.' + str(n_race + 1) + '.log', 'w')
        session.save_events(outfile,
                            bookmarks=bookmarks,
                            injects=injects,
                            cutoff=cutoff)
        outfile.close()

        n_race += 1
        if (n_race == args.number):
            break;

    logging.info('-' * 75)
    logging.info('Generated %d logs out of total %d races examined',
                 n_race, n_race + n_fail)

    return n_race

##############################################################################

def test_races(args):
    cmd_replay = 'sudo replay -c 1'
    cmd_suffix = ' 2>&1 > /dev/null' if not args.silent else ''

    logfile = os.path.join(args.dir, args.logfile)

    for n in range(args.number):
        try:
            os.unlink('%s.%d.log' % (args.outfile, n))
        except OSError:
            pass

    nr = show_races(args)

    for n in range(1, nr + 1):
        if args.script_pre:
            ret = os.system('sudo ' + args.script_pre + cmd_suffix)
            if ret > 0:
                logging.info('Bad exit code %d from pre-script'
                             ' (race %d)... skipping' % (ret, n))
                continue;

        ret = os.system('%s %s.%d.log %s' %
                        (cmd_replay, args.outfile, n, cmd_suffix))
        if ret > 0:
            logging.info('REPLAY %2d failed (exit %d)' % (n, ret))
            continue
        else:
            logging.info('REPLAY %2d completed' % n)
            success = True

        if args.script_test:
            ret = os.system('sudo ' + args.script_test + cmd_suffix)
            if ret == 2:
                logging.info('Bad exit code %d from test-script'
                             ' (race %d)... skipping' % (ret, n))
                continue
            success = True if ret == 1 else False

        logging.info('BUG %s' % 'PRODUCED' if success else 'not triggered')

        if args.script_post:
            ret = os.system('sudo ' + args.script_post + cmd_suffix)
            if ret > 0:
                logging.info('Bad exit code %d from post-script'
                             ' (race %d)' % (ret, n))

##############################################################################

parser_def = argparse.ArgumentParser(add_help=False)
parser_def.add_argument('-i', '--input', dest='logfile',
                        metavar='FILE', required=True)
parser_def.add_argument('-o', '--output', dest='outfile',
                        metavar='FILE', required=True)

desc = 'Process and modify scribe execution log'
parser = argparse.ArgumentParser(description=desc)
parser.add_argument('-d', dest='debug',
                    action='store_true', default=False,
                    help='Increase debug vebosity')
parser.add_argument('-v', dest='verbose',
                    action='store_true', default=False,
                    help='Increase vebosity level')

subparsers = parser.add_subparsers(title='subcommands')

test_races_opts = [
    ( 'number', 'NUM', 100 ),
    ( 'random', None, False ),
    ( 'dir', 'DIR', './' ),
    ( 'script-pre', 'SCRIPT', None ),
    ( 'script-post', 'SCRIPT', None ),
    ( 'script-test', 'SCRIPT', None ),
    ( 'silent', None, False ),
    ]

show_races_opts = [
    ( 'number', 'NUM', 100 ),
    ( 'random', None, False ),
    ( 'dir', 'DIR', './' ),
    ]

commands = [
    ('show-graph', show_graph, list()),
    ('show-races', show_races, show_races_opts),
    ('find-races', test_races, test_races_opts),
    ]

for cmd, func, opts in commands:
    parser_cmd = subparsers.add_parser(cmd, parents=[parser_def])
    parser_cmd.set_defaults(func=func)
    for opt, meta, dflt in opts:
        parser_cmd.add_argument('--' + opt, metavar=meta,
                                dest=opt.replace('-','_'), default=dflt)

args = parser.parse_args()

log = logging.ERROR
if args.verbose: log = logging.INFO
if args.debug: log = logging.DEBUG
logging.basicConfig(level=log, stream=sys.stdout)

ret = args.func(args)

exit(ret)
