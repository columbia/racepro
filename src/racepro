#!/usr/bin/python

import os
import sys
import pdb
import random
import argparse
import subprocess
import logging
import networkx
import pygraphviz
from itertools import *

import scribe
import racepro
import unistd

def load_session(logfile):
    try:
        file = open(logfile, 'r')
    except:
        print('Cannot open log file')
        exit(1)

    session = racepro.Session()
    session.load_events(file)
    file.close()

    return session

def do_exec(cmd):
    return subprocess.call(cmd.split())

##############################################################################

def diet_graph(graph):
    for n in graph.nodes():
        if graph.in_degree(n) != 1 or graph.out_degree(n) != 1:
            continue
        t = graph.successors(n)[0]
        s = graph.predecessors(n)[0]
        if s.split(':')[0] != n.split(':')[0]:
            continue
        if n.split(':')[0] != t.split(':')[0]:
            continue
        graph.remove_edge(s, n)
        graph.remove_edge(n, t)
        graph.remove_node(n)
        graph.add_edge(s, t)

def show_graph(args):

    def style_cluster(graph, output):
        with open(output, 'w') as file:
            file.write('digraph G {\n')
            for pid in session.process_map.keys():
                file.write('\tsubgraph cluster_%d {\n' % pid)
                nodes = [ n for n in graph.nodes() if n.split(':')[0] == str(pid) ]
                nodes.sort(key=lambda n : int(n.split(':')[1]))
                file.write('\t\t"' + '" -> "'.join(nodes) + '";\n')
                file.write('\t}\n')
            for s, t in graph.edges():
                if s.split(':')[0] != t.split(':')[0]:
                    file.write('\t"%s" -> "%s";\n' % (s, t))
            file.write('}\n')

    def style_plain(graph, output):
        networkx.write_dot(graph, output)

    def do_filter_graph(graph):

        def convert(s):
            pid = int(s[0])
            s, e = map(int, s[1].split(':')) if len(s) > 1 else (0, sys.maxint)
            return (pid, (s, e))

        pids = dict(map(convert, [s.split('=') for s in args.pids.split(',')]))

        for s, t in graph.edges():
            ps, ns = map(int, s.split(':'))
            pt, nt = map(int, t.split(':'))
            if (ps not in pids or ns < pids[ps][0] or ns > pids[ps][1] or
                pt not in pids or nt < pids[pt][0] or nt > pids[pt][1]):
                graph.remove_edge(s, t)
        for n in graph.nodes():
            pn, nn = map(int, n.split(':'))
            if pn not in pids or nn < pids[pn][0] or nn > pids[pn][1]:
                graph.remove_node(n)

    def do_show_graph(graph, output):
        plot = style_cluster if args.clustered else style_plain
        plot(graph, output + '.dot')
        if args.pdf:
            g = pygraphviz.AGraph(output + '.dot')
            g.layout(prog='dot')
            g.draw(output + '.pdf')

    session = load_session(args.logfile)
    graph = session.make_graph(full=False, resources=False)
    if args.pids: do_filter_graph(graph)
    if args.thin: diet_graph(graph)
    do_show_graph(graph, args.outfile + '.hb')

    session = load_session(args.logfile)
    graph = session.make_graph(full=True, resources=True)
    if args.pids: do_filter_graph(graph)
    if args.thin: diet_graph(graph)
    do_show_graph(graph, args.outfile + '.ob')

    return 0

##############################################################################
def show_syscalls(args):
    session = load_session(args.logfile)
    for pid in session.process_map.keys():
        print('')
        session.syscalls_process(pid)
    return 0

##############################################################################
def show_profile(args):
    session = load_session(args.logfile)
    for pid in session.process_map.keys():
        print('')
        session.profile_process(pid)
    return 0

##############################################################################

def show_races(args):
    session = load_session(args.logfile)

    graph = session.make_graph(full=True, resources=True)
    logging.debug('graph: %s' % networkx.convert.to_edgelist(graph))

    vclocks = session.vclock_graph(graph)
    for k in vclocks.keys():
        logging.debug('%2d %5d -> %s' % (k[0].pid, k[1], vclocks[k]))

    # YJF: show sysaclls with clocks
    if args.debug:
        for proc in session.process_list:
            session.syscalls_process(proc.pid, vclocks)

    all_races = session.races_resources(vclocks)
    logging.debug('total races %d' % (len(all_races)))

    sys_races = set()
    map_races = dict()

    for vc1, i1, vc2, i2 in all_races:
        s_ev1 = session.events[i1]
        r_ev1 = s_ev1.resource.events[s_ev1.rindex]
        proc1, pindex1 = session.r_ev_to_proc(r_ev1, sysind=True)
        p_ev1 = proc1.events[pindex1]
        node1 = session.make_node(proc1.pid, p_ev1.syscnt)

        s_ev2 = session.events[i2]
        r_ev2 = s_ev2.resource.events[s_ev2.rindex]
        proc2, pindex2 = session.r_ev_to_proc(r_ev2, sysind=True)
        p_ev2 = proc2.events[pindex2]
        node2 = session.make_node(proc2.pid, p_ev2.syscnt)

        logging.debug('[vc %s pid %d cnt %d  <->  vc %s pid %d cnt %d]' %
                      (vc1, proc1.pid, p_ev1.syscnt,
                       vc2, proc2.pid, p_ev2.syscnt))

        assert r_ev1.event.serial != r_ev2.event.serial, \
            'Race between %s and %s with same serial' % \
            (r_ev1.event, e_ev2.event)

        if r_ev1.event.serial < r_ev2.event.serial:
            node1, node2 = node2, node1
            i1, i2 = i2, i1

        logging.info('\tadding %s --> %s to races' % (node1, node2))

        sys_races.add((node1, node2))

        try:
            map_races[(node1, node2)].append((i1, i2))
        except KeyError:
            map_races[(node1, node2)] = list([(i1, i2)])

    print('-' * 75)
    print('Found %d potential races (%d after duplicates removal)' %
          (len(all_races), len(sys_races)))

    if len(all_races) == 0:
        return 0

    if args.random:
        r = random.sample(sys_races, len(sys_races))
        print('Random sample to generate at most %d races:' % (args.count))
    else:
        r = sys_races

    print('-' * 75)

    n_race = 0
    n_fail = 0

    for (node1, node2) in r:
        proc1, cnt1 = session.split_node(node1)
        event1 = session.events[int(graph.node[node1]['index'])].event

        proc2, cnt2 = session.split_node(node2)
        event2 = session.events[int(graph.node[node2]['index'])].event

        # YJF: print out race
        if args.debug:
            print('Two racing system calls are:');
            sys.stdout.write('p%d @ %s:' 
                             % (proc1.pid, vclocks[(proc1, cnt1)]));
            session.parse_syscall(int(graph.node[node1]['index']));
            sys.stdout.write('p%d @ %s:' 
                             % (proc2.pid, vclocks[(proc2, cnt2)]));
            session.parse_syscall(int(graph.node[node2]['index']));

        # YJF: TODO: sort races.  races on stdout or stderr not
        # interesting, mostly.  races on file data more interesting than
        # stat v.s. write race

        bookmark1 = session.crosscut_graph(graph, vclocks, node1, node2)
        if not bookmark1:
            print('No consistent cut: pid %d syscnt %d --> pid %d syscnt %d' %
                  (proc1.pid, cnt1, proc2.pid, cnt2))
            n_fail += 1
            continue

        bookmark2 = dict(bookmark1)
        bookmark2[proc1.pid] = -bookmark2[proc1.pid]
        bookmarks = [bookmark1, bookmark2]

        action = racepro.Action(scribe.SCRIBE_INJECT_ACTION_PSFLAGS,
                                0, scribe.SCRIBE_PS_ENABLE_RESOURCE)
        injects = dict()
        injects[proc1.pid] = dict({-cnt1 : action})

        cutoff = dict(bookmark2)

        print('RACE %2d:  ' % (n_race + 1) +
              'pid %d syscnt %d [sys(%d)=%d]' %
              (proc1.pid, cnt1, event1.nr, event1.ret) +
              '  -->   pid %d syscnt %d [sys(%d)=%d]' %
              (proc2.pid, cnt2, event2.nr, event2.ret))
        print('          cut:  %s' % bookmark1.values())

        logging.debug('   boobkmark1: %s' % (bookmark1))
        logging.debug('   boobkmark2: %s' % (bookmark2))
        logging.debug('      injects: %s' % (injects))
        logging.debug('       cutoff: %s' % (cutoff))

        outfile = open(args.outfile + '.' + str(n_race + 1) + '.log', 'w')
        session.save_events(outfile,
                            bookmarks=bookmarks,
                            injects=injects,
                            cutoff=cutoff)
        outfile.close()

        # YJF: condense event serial and rewrite log
        outfile = open(args.outfile + '.' + str(n_race + 1) + '.log', 'r')
        # create a newsession so it's easier for me to traverse the log
        newsession = racepro.Session()
        newsession.load_events(outfile)
        newsession.condense_events()
        outfile.close()
        outfile = open(args.outfile + '.' + str(n_race + 1) + '.log', 'w')
        newsession.save_events(outfile)
        outfile.close()

        n_race += 1
        if (n_race == args.count):
            break;

    print('-' * 75)
    print('Generated %d logs out of total %d races examined' %
          (n_race, n_race + n_fail))
    print('-' * 75)

    return n_race

##############################################################################

def test_races(args):
    cmd_replay = 'sudo replay -c %d' % int(args.timeout)
    cmd_suffix = ' > /dev/null 2>&1' if args.silent else ''

    if args.detect:
        total = show_races(args)
    else:
        total = -1

    n = 0
    while True:
        n += 1
        if total >= 0 and n > total:
            break;
        logfile = '%s.%d.log' % (args.outfile, n)
        if not os.access(logfile, os.R_OK):
            break

        if args.script_pre:
            r = do_exec('/usr/bin/sudo ' + args.script_pre + cmd_suffix)
            if r > 0:
                print('RACE %d: bad exit code %d from pre-script' % (n, r))
                continue;

        r = do_exec('%s %s %s' % (cmd_replay, logfile, cmd_suffix))
        if r == 35:
            print('REPLAY %2d: deadlock (exit %d)' % (n, r))
            continue
        if r > 0:
            print('REPLAY %2d: failed (exit %d)' % (n, r))
            return -1
        else:
            print('REPLAY %2d: completed' % n)

        if args.script_test:
            r = do_exec('sudo ' + args.script_test + cmd_suffix)
            if r == 2:
                print('RACE %d: bad exit code %d from test-script' % (n, r))
            elif r == 1:
                print('    BUG PRODUCED')
            else:
                print('    BUG not triggered')
        else:
            print('    BUG only replayed')

        if args.script_post:
            r = do_exec('sudo ' + args.script_post + cmd_suffix)
            if ret > 0:
                print('RACE %d: nad exit code %d from post-script' % (n, r))

    return 0

##############################################################################

parser_io = argparse.ArgumentParser(add_help=False)
parser_io.add_argument('-i', '--input', dest='logfile',
                       metavar='FILE', required=True)
parser_io.add_argument('-o', '--output', dest='outfile',
                       metavar='FILE', required=True)

parser_races = argparse.ArgumentParser(add_help=False)
parser_races.add_argument('-c', '--count', dest='count',
                          metavar='COUNT', type=int, default=1000,
                          help='Limit results to COUNT races')
parser_races.add_argument('-r', '--random', dest='random',
                          action='store_true', default=False,
                          help='List races in random order')

desc = 'Process and modify scribe execution log'
parser = argparse.ArgumentParser(description=desc)
parser.add_argument('-d', dest='debug',
                    action='store_true', default=False,
                    help='Increase debug vebosity')
parser.add_argument('-v', dest='verbose',
                    action='store_true', default=False,
                    help='Increase vebosity level')

subparsers = parser.add_subparsers(title='subcommands')

parser_show_graph = subparsers.add_parser(
    'show-graph', parents=[parser_io])
parser_show_graph.set_defaults(func=show_graph)
parser_show_graph.add_argument('-c', '--clustered', dest='clustered',
                               action='store_true',
                               help='Clustered output style')
parser_show_graph.add_argument('-t', '--thin', dest='thin',
                               action='store_true',
                               help='Thin mode (minimal syscalls graph)')
parser_show_graph.add_argument('--pdf', dest='pdf',
                               action='store_true',
                               help='Output graph in PDF format')
parser_show_graph.add_argument('-p', '--pids', dest='pids',
                               metavar='PID[,PID...]', default='',
                               help='Pid(s) to include in the graph')

parser_show_syscalls = subparsers.add_parser(
    'show-syscalls', parents=[parser_io])
parser_show_syscalls.set_defaults(func=show_syscalls)

parser_show_profile = subparsers.add_parser(
    'show-profile', parents=[parser_io])
parser_show_profile.set_defaults(func=show_profile)

parser_show_races = subparsers.add_parser(
    'show-races', parents=[parser_io, parser_races])
parser_show_races.set_defaults(func=show_races)

parser_test_races = subparsers.add_parser(
    'test-races', parents=[parser_io, parser_races])
parser_test_races.set_defaults(func=test_races)
parser_test_races.add_argument('--script-pre', dest='script_pre',
                               default=None,
                               help='Script to run before test')
parser_test_races.add_argument('--timeout', dest='timeout',
                               default=1,
                               help='Log replay timeout')
parser_test_races.add_argument('--script-post', dest='script_post',
                               default=None,
                               help='Script to run after test')
parser_test_races.add_argument('--script-test', dest='script_test',
                               default=None,
                               help='Script to check success of test')
parser_test_races.add_argument('-s', '--silent', dest='silent',
                               action='store_true', default=False,
                               help='Hide scribe/scripts/tests output')
parser_test_races.add_argument('-d', '--detect', dest='detect',
                               action='store_true', default=False,
                               help='Detect races and generate logs')

args = parser.parse_args()

log = logging.ERROR
if args.verbose: log = logging.INFO
if args.debug: log = logging.DEBUG
logging.basicConfig(level=log, stream=sys.stdout)

ret = args.func(args)
exit(0 if ret >= 0 else -ret)
